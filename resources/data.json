[
    {
        "question": "접근 제어자의 종류엔 어떤게 있는지 설명해 주세요.",
        "answer": "접근한정자의 종류는 open, public, internal, fileprivate, private\nopen은 가장 열려있는 접근 한정자이고 전체적으로는 public과 유사하지만\n타모듈에서 만들어진 class의 접근한정자가 open 이면 상속을 할수 있다.\n타모듈에서 만들어진 method의 접근한정자가 open이면 override를 할수 있다.\n같은 모듈에서는 public이나 internal과 동일하다.\n\npublic는 다른 모듈의 public 로 된 클래스를 상속할려고 하면 Cannot inherit from non-open class '' outside of its defining module 이란 class가 open 되지 않았다는 에러가 나온다.\n다른 모듈의 public로 된 메서드를 override 하려고 하면 Overriding non-open instance method outside of its defining module 이란 method가 open되지 않았다는 에러가 나온다.\n\ninternal은 타 모듈에서 internal 접근한정자로 만들어진 클래스를 코드에서는 가져올 수 없지만 storyboard, xib에서는 가져올 수 있다. 접근한정자를 지정하지 않았을 때 기본적으로 사용 되는 접근 수준이고 같은 모듈 에서는 자유롭게 사용 가능하다.\n\nfileprivate은 클래스는 같은 파일 내에서만 접근 가능하고 메서드도 같은 파일 내에서만 접근 가능하다.\n\nprivate은 클래스는 같은 파일 내에서만 접근 가능하고 메서드는 같은 블록(클래스) 내에서만 접근 가능하다.\n같은 파일에서는 이렇게 extension 안에서도 class, struct, enum등 같은 영역에서는 접근 가능하다.\n\n접근한정자 뒤에 set을 붙여도 된다.\nset을 붙인다는 것은 name이나 age, gender를 접근할때는 internal수준으로 어디서든지 접근할수 있지만 set할때는 접근한정자를 따른다.\n타 모듈에서 set할 때는 접근한정자를 따르고 클라이언트는 get만 쓸 수 있게 하고 싶을때는 public private(set) 과 같이 쓸 수 있다."
    }, {
        "question": "Bounds 와 Frame 의 차이점을 설명해 주세요.",
        "answer": "Bounds와 Frame의 차이는 x, y 좌표인데 Bounds는 자기 자신의 좌표계로 설정되고 Frame은 Superview를 기준으로 x, y좌표가 설정된다.\nFrame의 x, y좌표를 변경하면 자기자신과 자신의 subviews들의 위치가 변경이 되는데\nBounds의 x,y 좌표를 변경하면 subviews들의 x,y 좌표는 변하지 않았지만 위치가 변경된다.\nView를 회전시켰을때 View의 Frame은 회전한 상태에 대해 출력이 되는데 View Bounds는 회전 상태에 상관없다.\nbounds의 좌표를 변경했을때 자식 뷰들의 좌표가 반대로 이동을 한다."
    }, {
        "question": "오토레이아웃에서 hugging, resistance에 대해서 설명해 주세요.",
        "answer": "Hugging은 슈퍼뷰의 크기가 서브뷰의 크기보다 큰 경우 서브뷰의 우선순위를 줘서\n우선순위에 따라 영역이 컨텐츠에 대해 최소로 잡히거나\n남은 영역에 대해 최대로 잡히게 할수있다.\n\nCompression Resistance는\n슈퍼뷰의 크기가 서브뷰의 크기보다 작은 경우 서브뷰의 우선순위를 줘서\n우선순위에 따라 서브뷰 끼리의 컨텐츠 영역을 짤라서\n더 많이 보이게 할수있다."
    }, {
        "question": "오토레이아웃에서 Left Constraint 와 Leading Constraint 의 차이점을 설명해 주세요.",
        "answer": "leading는 항상 왼쪽이 아니다. 언어(Locale)에 따라 오른쪽이 될수 있다."
    }, {
        "question": "ARC에 대해서 설명해 주세요.",
        "answer": "프로퍼티, 상수, 변수등을 참조하면 레퍼런스가 카운트가 올라가고\n참조가 해제되면 내려가고 0이되면 해제한다.\n자동 레퍼런트 카운터는 더 이상 사용되지 않는 시점을 결정하여 메모리를 해제한다.\n그리고 ARC는 compile time에 코드 분석을 통해 적절한 위치에 retain, release 등의 코드를 삽입해 주고\n삽입된 코드는 run time에 실행이 된다\n옛날 MRC는 개발자가 직접 리테인과 릴리즈를 해줘야 했고\nretain, release를 통해 referenceCount를 증감시키다가 count 가 0이 되면 deinit 을 통해 해제를 하였다.\n이러한 작업을 ARC는 자동으로 해준다.\n\n메모리가 제대로 해지되지 않는 경우가 있고 순환참조라고 부른다.\n두 클래스 인스턴스의 프로퍼티가 서로를 강한 참조할 경우\n클로져 내부에서 객체를 참조할 경우\n\n해결방법은\nweak 약한참조 ([weak self] in 이나 [unowned self] in 를 캡쳐리스트라고 한다. self를 캡쳐한다.)\nunowned 미소유 참조\nweak와 언노운은 레퍼런스 카운트를 증가시키지 않으며 대상객체에 대한 참조가 가능한 점은 동일하지만 객체가 해제된 경우에 다르다."
    }, {
        "question": "Swift의 캡쳐에 대해 설명해 주세요.",
        "answer": "Swift에서는 capture를 사용하지 않으면 reference capture가 일어난다.\n(struct로 만들어진 객체 변수도 레퍼런스 카운터가 올라간다.)\nCapture를 사용하면 value copy가 된다.\nunowned는 옵셔널이 아닌 경우 확실히 있는 경우에만 사용합니다. 만약 객체의 메모리가 해제된 경우 unowned에 접근하면 bad access에러가 납니다.\nweak 같은 경우는 메모리가 해제 된 경우 nil이 나옵니다."
    }, {
        "question": "Autorelease Pool을 사용해야 하는 상황을 예로 들어 설명해 주세요.",
        "answer": "반복적으로 메모리를 많이 차지하는 로직을 사용할때 메모리가 해제되지 않고 앱이 죽어버리는 경우가 있다.\n메모리를 해제할 시간을 주지않고 계속 메모리를 사용을 해서 생기는 문제이다.\n이런 경우에 autoreleasepool을 사용하게 되면 특정 로직을 실행하기 전에 임시오토릴리즈풀이 만들어지고 블럭을 빠져나간 뒤에 임시오토릴리즈풀은 비워지게 되면서 메모리 사용량이 다시 줄어들게 된다.\n오토릴리즈풀 블럭 안에서는 return이 되지 않는다. break 는 컴파일에러가 난다.\nautoreleasepool 함수 안에서 리턴값으로 Result를 받는다.\nautoreleasepool 함수는 Result를 리턴해준다."
    }, {
        "question": "하나의 자원에 접근할 때 동시에 여러 쓰레드에서 그 하나의 자원에 접근한다면 어떻게 해결할지 설명해 주세요.",
        "answer": "이렇게 하나의 자원에 여러 곳에서 접근을 하는 것을 레이스 컨디션(Race Condition)이라고 한다.\n동기화 방법은 크리티컬 섹션(Critical Section)이라고 한다.\n임계영역 이라고도 한다.\n동시 접근 문제를 해결하기 위한 동기화 기법이 세마포어, 뮤텍스 등이 있다.\nDispatchSemaphore의 메서드에는\nwait: value값이 -1 작아진다.\nsignal: value 값이 +1 더해진다."
    }, {
        "question": "mutating 키워드에 대해 설명해 주세요.",
        "answer": "struct나 protocol 확장 에서 self 변수를 참조해 수정하려면 mutating을 써야 한다.\nstruct에서 변수의 값이 변경되면 struct 전체가 복사되고 주소값이 변경이 된다.\n값이 변경될 때 struct가 복사되는 이유는 swift가 함수형 언어이고 불변성이 중요한 요소라서 전체가 복사가 되고 주소값이 변경이 된다. 그러면 다중 쓰레드에서 세이프하게 작동할 수 있게 된다."
    }, {
        "question": "실제 디바이스가 없을 경우 개발 환경에서 할 수 있는 것과 없는 것을 설명하시오.",
        "answer": "카메라를 열거나 불루투스 등의 기능은 시뮬레이터에서 할 수 없습니다.\n기기를 수평으로 변경한 상태인 faceup, facdown을 하지 못한다.\n사진첩을 열거나, 회전 등은 시뮬레이터에서 가능하고 페이스 아이디는 시뮬레이터의 메뉴에서 인식여부를 처리할수 있습니다."
    }, {
        "question": "앱이 foreground에 있을 때와 background에 있을 때 어떤 제약사항이 있나요?",
        "answer": "앱 푸시를 받을때 포그라운드에 있을때는 푸시에 대한 처리를 할 수 있는데 백그라운드에서의 푸시는 처리할 수 없습니다.\n그리고 백그라운드에 들어갔을때는 작업을 수행할 수 없는데 BackgroundTask를 사용하여 작업을 할 수 있습니다."
    }, {
        "question": "상태 변화에 따라 다른 동작을 처리하기 위한 앱델리게이트 메서드들을 설명하시오.",
        "answer": "willFinishLaunchingWithOptions: 어플리케이션이 실핼될때\ndidFinishLaunchingWithOptions: 어플리케이션이 실행된 직후\napplicationWillResignActive: inactive상태로 전환되기 직전\napplicationDidEnterBackground: 백그라운드 상태로 전환한 직후\napplicationWillEnterForeground: active상태가 되기 직전\napplicationDidBecomeActive: active상태로 전환된 직후\napplicationWillTerminate: 어플리케이션이 종료되기 직전"
    }, {
        "question": "scene delegate에 대해 설명하시오.",
        "answer": "iOS 13부터는 window 가 scene으로 대체되고 하나의 앱에서 여러 secene를 가질수 있게 되었습니다.\nscene willConnectTo는 scene이 앱에 추가될때 호출됩니다.\nsceneDidDisconnect는 scene의 연결이 해제될때 호출됩니다.\nsceneDidBecomeActive는 app switcher에서 선택되는 등 scene과 상호작용이시작될때 호출됩니다.\nsceneWillResignActive은 상호작용이 중지될때 호출됩니다.\nsceneWillEnterForeground는 scene이 포그라운드로 진입할때 호출됩니다.\nsceneDidEnterBackground는 scene이 백그라운드로 진입할때 호출됩니다.\n\n앱딜리게이트에서는 application configurationForConnecting가 추가되었고 scene을 만들때 구성객체를 반환해야 합니다.\napplication didDiscardSceneSessions 사용자가 app switcher를 통해 scene를 닫을때 호출됩니다."
    }, {
        "question": "앱이 In-Active 상태가 되는 시나리오를 설명하시오.",
        "answer": "앱이 이벤트를 받지 못하는 상태이고\n예를들면 다른 앱의 알림이 열려서 이벤트를 수신하지 못하거나 앱 스위쳐로 전환되었을때"
    }, {
        "question": "NSOperationQueue 와 GCD Queue 의 차이점을 설명하시오.",
        "answer": "GCD는 C기반의 저수준 API이고 오퍼레이션은 Obj-c기반으로 만들어진 고수준 API이다.\n오퍼레이션은 내부적으로 GCD를 사용한다.\n그리고 디펜전시를 줄수 있고 재사용, 취소, 중지를 할수 있지만 추가적인 오버헤드가 있다."
    }, {
        "question": "GCD API 동작 방식과 필요성에 대해 설명하시오.",
        "answer": "직렬로 실행되는 시리얼큐와 병렬로 실행되는 컨커런트큐가 있습니다.\n그리고 UI와 관련된 작업을 할 수 있는 main 쓰레드 큐와 ui를 제외한 작업에서 사용되는 global쓰레드 큐가 있습니다.\nmain 쓰레드큐는 serial큐로 동작되고 global 글로벌큐는 컨커런트큐로 동작됩니다.\n그리고 몇가지의 작업 우선순위를 줄 수 있습니다.\n필요성은 이미지 다운로드와 같이 오래 걸리는 작업을 처리하려면 해당 작업이 끝날때 까지 화면이 프리징상태가 되는데 프리징상태가 되지 않게 하기 위해 사용합니다."
    }, {
        "question": "자신만의 Custom View를 만들려면 어떻게 해야하는지 설명하시오.",
        "answer": "Xib를 사용하는 방식으로는 UIView를 상속받는 클래스를 만들고 Custom Class에 클래스명을 추가합니다.\n사용하는 곳에서 Bundle.main.loadNibNamed 또는 UINib클래스로 가져옵니다. 이 방법은 required init만 호출이 됩니다.\n\n또는 Xib의 Files's Owner에 클래스를 넣고 클래스 안에서 Bundle.main.loadNib를 사용하는 방식이 있습니다. Files's Owner에 클래스명을 넣는 이유는 인터페이스 빌더를 연결하기 위해서 넣습니다.\n이 방법은 일반 클래스 인스턴스를 만드는 작업이기 때문에 override init가 호출됩니다."
    }, {
        "question": "iOS 앱을 만들고, User Interface를 구성하는 데 필수적인 프레임워크 이름은 무엇인가?",
        "answer": "UIKit입니다. 뷰, 제스쳐, 애니메이션, 그림그리기 등의 처리를 할 수 있습니다."
    }, {
        "question": "Foundation Kit은 무엇이고 포함되어 있는 클래스들은 어떤 것이 있는지 설명하시오.",
        "answer": "Cocoa Touch framework에 포함되어 있는 프레임워크이고 String, Int등 원시 테이터 타입과 컬렉션타입, 파일시스템등 서비스를 사용할수 있습니다."
    }, {
        "question": "Delegate란 무언인가 설명하고, retain 되는지 안되는지 그 이유를 함께 설명하시오.",
        "answer": "하나의 객체가 모든 일을 처리하지 않고 처리해야 할 일의 일부를 다른 객체에게 위임하는것이고 객체간 결합성을 최소화 할 수 있습니다.\nDelegate는 retain됩니다. \n해결하려면 weak를 써야 합니다.\nweak 를 사용하려고 할때 에러가 납니다. 에러는 프로토콜에 AnyObject나 class를 적으면 사라집니다.\n프로토콜이 AnyObject나 class에서만 채택할수 있게 선언하는 것입니다.\n에러가 나는 이유는 프로토콜이 클래스에서 사용되는지 구조체나 열거형에서 사용되는지 알수 없기 때문에 unowned나 weak를 사용할수 없습니다."
    }, {
        "question": "NotificationCenter 동작 방식과 활용 방안에 대해 설명하시오.",
        "answer": "옵저버를 등록할수 있고 등록된 옵저버들에게 정보를 전달합니다.\n화면간에서 딜리게이트로 연결하기 힘든 화면 또는 연결점이 없는 화면에서 정보를 주고 받을필요가 있을때 사용하였습니다."
    }, {
        "question": "UIKit 클래스들을 다룰 때 꼭 처리해야하는 애플리케이션 쓰레드 이름은 무엇인가?",
        "answer": "Main Thread"
    }, {
        "question": "TableView를 동작 방식과 화면에 Cell을 출력하기 위해 최소한 구현해야 하는 DataSource 메서드를 설명하시오.",
        "answer": "row 갯수를 지정해주고 cell를 지정해줍니다."
    }, {
        "question": "하나의 View Controller 코드에서 여러 TableView Controller 역할을 해야 할 경우 어떻게 구분해서 구현해야 하는지 설명하시오.",
        "answer": "delegate와 datasource에서는 거의 첫번째 아규먼트로 tableView를 받는다. 받은 tableView를 여려 테이블뷰와 비교하여 구현을 합니다."
    }, {
        "question": "App Bundle의 구조와 역할에 대해 설명하시오.",
        "answer": "Info.plist와 Executable, Resoruce Files, Other Support Files가 있고\nInfo.plist는 응용 프로그램에 대한 구성 정보 등이 있고\nExecutable은 실행파일이고 어플리케이션의 기본 진입점과 정적으로 링크된 모든 코드가 포함되어 있다.\n리소스 파일은 일반적으로 이미지, 사운드, nib파일, 문자열파일, 데이터파일등이고\n\niOS APP Bundle의 구조는\nMyApp. 어플리케이션 코드를 포함하는 실행파일\nInfo.plist. 번들 ID, 버전번호, 이름등 구성 정보는 필수이고\n런치 이미지, MainWindow.nib 는 권장이 있다.\n그리고 Setting.bundle, 사용자 지정 리소스 파일이 있다.\n"
    }, {
        "question": "View 객체에 대해 설명하시오.",
        "answer": "사용자 인터페이스의 기본 구성 요소이고 UIResponder를 상속받는다.\nUIButton, UILabel등의 상위 클래스이고 조작은 메인 스레드에서 해야 한다.\n메인 스레드가 필요하지 않을 수 있는 케이스는 뷰 객체를 생성할때 뿐이다."
    }, {
        "question": "UIView 에서 Layer 객체는 무엇이고 어떤 역할을 담당하는지 설명하시오.",
        "answer": "UIView가 가지고 있는 속성이고 Core Animation API가 제공하는 요소이다.\n애니메이션, View 형태 변환등을 처리할 수 있고 UIView에서 화면 표시하는 부분을 해준다."
    }, {
        "question": "UIWindow 객체의 역할은 무엇인가?",
        "answer": "UI를 위한 환경을 제공하고 어플리케이션의 뷰, 객체에 이벤트를 전달하는 역활을 담당한다.\nmakeKey 메서드를 사용해 키보드 이벤트를 받는 설정을 할 수 있다."
    }, {
        "question": "UINavigationController 의 역할이 무엇인지 설명하시오.",
        "answer": "스택 구조로 하위 뷰컨트롤러들을 감싸고 있다.\n하위 뷰컨트롤러의 현재 보여주고 있는 프레젠트 뷰컨트롤러는 마지막 뷰컨트롤러이다."
    }, {
        "question": "모든 View Controller 객체의 상위 클래스는 무엇이고 그 역할은 무엇인가?",
        "answer": "네비컨트롤러타 탭바컨트롤러들은 UIViewController를 상속받고 UIViewController는 UIResponder를 상속받는다.\n뷰컨트롤러의 역활은 데이터의 변경과 뷰의 콘텐츠를 업데이트하고\n뷰 크기 조정 및 레이아웃관리 등을 하고\nUIResponder는 이벤트등을 관리한다. 이벤트가 발생하면 UIKit은 이벤트를 처리할 수 있도록 리스폰더 객체에 전달한다."
    }, {
        "question": "앱이 시작할 때 main.c 에 있는 UIApplicationMain 함수에 의해서 생성되는 객체는 무엇인가?",
        "answer": "UIApplication 싱글턴 객체가 생성된다.\n메인함수 실행 - UIApplicationMain 함수호출 - UIApplication객체 생성\nInfo.plist파일을 읽고 데이터로드 - 앱딜리게이트 객새 만들고 연결\n런루프 만드는 등 실행에 필요한 준비를 하고 앱 객체가 앱 딜리게이트에게 didFinishLaunch호출"
    }, {
        "question": "앱의 콘텐츠나 데이터 자체를 저장/보관하는 특별한 객체를 무엇이라고 하는가?",
        "answer": "앱이 종료되어도 데이터가 남아 있는 Core Data, SQLite, UserDefaults가 있고\n앱이 있을때만 데이터가 있는 in-memory인 cache등이 있다."
    }, {
        "question": "앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체를 무엇이라고 하는가?",
        "answer": "UIViewController라고 하고 View 컨텐츠를 업데이트, View의 크기, 레이아웃관리를 할 수 있다."
    }, {
        "question": "Swift의 클로저와 Objective-C의 블록은 어떤 차이가 있는가?",
        "answer": "Swift의 클로저는 변수를 캡쳐할때 캡쳐리스트가 없으면 레퍼런스 카피가 되고\nObjective-C의 블럭은 캡쳐시 기본적으로 value카피이고 레퍼런스 카피를 하려면 캡쳐할 변수를 선언할때 __block 키워드를 써야 한다.\n일반적인 객체는 힙영역에 할당되지만 블럭은 스택에 할당된다."
    }, {
        "question": "App의 Not running, Inactive, Active, Background, Suspended에 대해 설명하시오.",
        "answer": "Not running: 앱이 실행되지 않았거나 완전히 종료되어 동작이 없는 상태\nInactive: 앱이 실행중이지만 이벤트를 받을 수 없는 상태\nActive: 앱이 실행중이고 이벤트를 받을 수 있는 상태\nBackground: 앱이 홈화면으로 나가거나 다른 앱으로 전환되어 실질적으로 동작하지 않는 상태. 코드를 실행할 수는 있다.\nSuspended: 앱이 백그라운드 상태에 진입헀을때 다른 작업을 하지 않으면 서스펜드 상태로 된다.\niOS의 메모리가 부족해지면 가장 먼저 메모리에서 해제되어서 다시 앱을 실행하면 처음부터 실행이 된다."
    }, {
        "question": "App thinning에 대해서 설명하시오.",
        "answer": "어플이 설치 될 때 앱스토어와 운영체제가 디바이스에 맞게 설치되도록 하는 기술이고\n최소한의 디스크 사용과 빠른다운로드를 할 수 있다.\n슬라이싱과 비트코드, on-demand resource가 있고\n슬라이싱은 여러 디바이스에 대해 각각 어플리케이션 번들을 생성하고 디바이스에 적합한 번들을 전달.\n비트코드는 기계코드로 번역되기 전단계의 중간 표현이고\n비트코드를 사용하여 업로드하면 애플이 어플리케이션을 재컴파일하여 앱 바이너리를 생성\n특정 아키텍쳐에 맞게 최적화\non-demand 리소스는 이미지, 사운드 등의 resource를 필요할때 다운받는 것이고 필요에 의해 백그라운드에서 리소스를 다운받고, 디스크 공간이 부족하거나 리소스가 필요업을때 제거됨"
    }, {
        "question": "Global DispatchQueue 의 Qos 에는 어떤 종류가 있는지, 각각 어떤 의미인지 설명하시오.",
        "answer": "userInteractive: 메인 스레드에서 작업, 사용자와 상호작용\nuserInitiated: 사용자가 시작한 작업이고 사용자가 인터페이스에서 터치 등을 했을때 작업을 수행하는것과 같은 즉각적인 결과\ndefault: global queue\nutility: 작업을 하는데 약간의 시간이 걸릴수 있다. 예를들어 DB작업\nbackground: 백그라운드작업이고 사용자가 볼수 없는 작업"
    }, {
        "question": "Intrinsic Size에 대해서 설명하시오.",
        "answer": "본질적인 컨텐츠 크기이고 Label이나 Button은 컨텐츠가 많아지면 자동으로 View의 크기를 크게 만들어주는 함수가 내부적으로 적용되어 있다."
    }, {
        "question": "스토리보드를 이용했을때의 장단점을 설명하시오.",
        "answer": "앱의 흐름을 한눈에 볼수 있고 바로바로 보인다. 시각적으로 볼수 있고 코드를 몰라도 만들수 있어서 진입장벽이 낮다.\n단점은 머지 컨플릭트 났을때 처리하기가 힘들고, xml로 작성되어 있어서 코드 비교로 알아보기 힘들다."
    }, {
        "question": "Safearea에 대해서 설명하시오.",
        "answer": "컨텐츠가 가리지 않는 영역이고 예를 들어 노치 디자인 Portrait에서 스테이터스바, 네비게이션바, 홈인디게이터바를 제외한 영역이고\nLandscape모드에서는 상하좌우 모두 margin이 생긴다."
    }, {
        "question": "Optional 이란 무엇인지 설명하시오.",
        "answer": "값이 존재할수도 존재하지 않을수도 있는 경우에 사용되고\n옵셔널 바인딩은 옵셔널 값이 존재하는지 체크하고 존재하면 값을 가져올수 있다\n옵셔널 체이닝은 옵셔널이 nil이면 체이닝을 중단하고 nil을 리턴하고 nil이 아니면 체이닝이 계속 되고 항상 옵셔널로 받는다.\nImplicitly Unwrapped Optionals은 옵셔널 강제 추출이고 느낌표로 사용된다. nil인 값에 사용하면 fatal error가 발생된다.\nNil-Coalescing Operator은 물음표로 사용된다."
    }, {
        "question": "Fast Enumeration 이란 무엇인지 설명하시오.",
        "answer": "for-in같은 간결한 구문을 사용하여 컬렉션의 내용을 효율적이고 안전하게 열거할수 있는 기능이다."
    }, {
        "question": "Struct 가 무엇이고 어떻게 사용하는지 설명하시오.",
        "answer": "구조체는 값 타입의 자료형을 만들때 사용한다.\ncall by value이고 내부 메서드에서 프로퍼티를 수정하려면 mutating 키워드를 붙여야 한다.\n뮤테이팅을 붙이는 이유는 내부 변수의 값이 변경되면 struct전체가 복사되고 주소값이 변경되기 때문에\n불변성이 중요한 요소라서 주소값이 변경이 된다.\n그러면 다중 쓰레드에서 세이프하게 작동할수 있다.\n자동 이니셜라이즈가 생성된다.\n구조체는 상속을 할수 없고 프로토콜 채택만 할수 있다.\n연관된 간단한 값이 집합을 캡슐화하는것이 목적일때\n캡슐화한 값을 참조하는것보다 복사하는것이 합당할때\n구조체에 저장된 프로퍼티가 값타입이며 참조하는것보다 복사하는것이 합당할때\n상속받거나 상속할 필요가 없을때"
    }, {
        "question": "instance 메서드와 class 메서드의 차이점을 설명하시오.",
        "answer": "인스턴스 메서드는 특정 클래스나 구조체, 열거형안에 속한 함수이고 클래스 메서드는 static키워드와 class키워드가 있는데 인스턴스를 생성하지 않고 사용을 할수 있다.\nclass는 오버라이드가 가능하고 final을 붙이면 상속이 안된다.\nstruct, enum에서는 class를 사용할수 없고 static만 사용할수 있다."
    }, {
        "question": "Delegate 패턴을 활용하는 경우를 예를 들어 설명하시오.",
        "answer": "객체가 다른 객체를 대신해 권한을 위임하는 패턴이다.\n예를들어 테이블뷰 딜리게이트를 터치했을때 위임받은 곳에서 행동을 하게 된다."
    }, {
        "question": "Singleton 패턴을 활용하는 경우를 예를 들어 설명하시오.",
        "answer": "예를들어 음악 재생 앱같은 경우 하나의 음악만 플레이를 할 수 있어야 하니까 싱글턴 패턴으로 활용할 수 있다."
    }, {
        "question": "KVO 동작 방식에 대해 설명하시오.",
        "answer": "특정 키 값의 변화를 감지하기 위한 기능이다.\n외부 라이브러리 등을 사용한 경우 내부 소스 수정을 할 수 없을때 KVO를 활용하여 프로퍼티 값 변화를 감지할 수 있다.\nobjc dynamic 을 사용하여 변화를 감지할 대상을 정할수 있다.\nNSObject를 상속하는 클래스만 사용가능하다."
    }, {
        "question": "Delegates와 Notification 방식의 차이점에 대해 설명하시오.",
        "answer": "delegate는 이벤트를 받는 대상이 하나지만 notification는 다수의 객체들에게 동시에 이벤트 발생을 알려줄 수 있다.\n하지만 notification은 추적이 쉽지 않다."
    }, {
        "question": "멀티 쓰레드로 동작하는 앱을 작성하고 싶을 때 고려할 수 있는 방식들을 설명하시오.",
        "answer": "UI 관련된 작업은 Main Thread에서 이루어져야 하고 \n쓰레드 세이프 하지 않는 변수는 서로 다른 쓰레드에서 접근할수 없게 해야 한다.\nImmutable한 객체는 쓰레드 세이프하기 떄문에 문제가 되지 않고\nMutable한 객체는 쓰레드 세이프 하지 않기 때문에 하나 이상의 쓰레드에서 변경이 이루어지면 문제가 발생할수도 있다.\n동시 접근을 막을때 Lock를 걸수 있고 한 자원에 한정된 자원만 접근할수 있게 할때 세마포어를 사용할 수 있다."
    }, {
        "question": "MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.",
        "answer": "모델, 뷰, 컨트롤러로 되어 있고\n모델은 데이터가 있는곳\n네트워크 코드나 데이터를 관리하는곳\n뷰는 어플상에서 보이는 곳이고\n컨트롤러는 뷰와 모델을 이어주는 역활이다.\n유저 액션이 일어나면 컨트롤러에 전달이 되고 컨트롤러에서는 모델 등을 업데이트한다.\n모델에서 자체 연산후 컨트롤러에게 알려주고(노티피) 컨트롤러는 뷰를 업데이트 한다.\niOS상의 MVC패턴은 뷰컨과 뷰가 강하게 연결되어 있어서 뷰컨트롤러가 거의 모든 일을 한다.\n\nMVVM에서는 뷰와 뷰컨이 합쳐졌다\n그리고 뷰가 뷰모델을 구독한다.\n커맨드 패턴과 데이터 바인딩\n뷰모델과 뷰는 1:n관계"
    }, {
        "question": "프로토콜이란 무엇인지 설명하시오.",
        "answer": "특정 작업이나 기능에 적합한 메서드, 프로퍼티 등의 청사진을 정의한다.\n선언만 할수 있고 구현은 포함되지 않는다.\n다중 상속이 가능하다.\n클래스, 열거형, 구조체에서 채택 가능하다.\nstruct에서 내부 값을 변화를 하는곳에서는 프로토콜 메서드에서 mutating를 사용해야 한다."
    }, {
        "question": "Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.",
        "answer": "정수 해쉬 값을 제공하기 위한 프로토콜이고\nEquatable은 ==메서드를 구현해 타입간 비교를 할수 있게 한다.\n셋이나 딕셔너리 키에 사용할때 해시 값을 이용해 중복을 확인한다."
    }, {
        "question": "mutating 키워드에 대해 설명하시오.",
        "answer": "객체를 바꾸는 함수을 알리는 키워드이다. 구조체는 값타입이라 스택메모리에 저장이 되고\nSwift에서는 값이 변경되었을때만 복사하도록 만들었다."
    }, {
        "question": "탈출 클로저에 대하여 설명하시오.",
        "answer": "클로저의 기본값은 non-escaping이고 컴파일러가 코드를 최적화 하는 과정에서 성능이 향상된다고 한다.\n함수로 전달한 클로저가 함수 종료 후에 호출이 되거나 벗어나서 실행될때 클로저가 함수를 탈출한다고 한다.\n이런 경우 @escapiing키워드를 사용하여 클로저가 탈출하는 것을 허용한다고 명시해줄수 있다."
    }, {
        "question": "Extension에 대해 설명하시오.",
        "answer": "수평적으로 확장하는 개념이고 클래스나 구조체, 열겨형, 프로토콜 타입에 새로운 기능을 추가할수 있다.\n계산 속성이나 타입 메서드, 이니셜라이저, 서브스크립트 등을 추가할수 있다.\n하지만 저장 프로퍼티는 추가할 수 없다."
    }, {
        "question": "defer란 무엇인지 설명하시오.",
        "answer": "함수 실행 후 함수가 끝나기 직전에 실행되는 블럭이다."
    }, {
        "question": "defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.",
        "answer": "디퍼를 작성한 역순으로 호출이 된다. 밑에 선언한 녀석이 먼저 선언된다.\n디퍼 구문이전에 리턴이 되거나 throw가 될때는 호출이 되지 않는다."
    }, {
        "question": "Retain Count 방식에 대해 설명하시오.",
        "answer": "리테인으로 객체의 레퍼런스 카운트를 증가시킬수 있다.\n릴리즈는 객체의 레퍼런스 카운터를 감소시키고 객체를 사용하지 않거나 메모리에 해제하고 싶을때 사용한다.\n인스턴스 생성에과 소유권 획득에는 alloc, new, copy, mutableCopy가 있다."
    }, {
        "question": "Strong 과 Weak 참조 방식에 대해 설명하시오.",
        "answer": "Strong은 강한 참조로 소유권을 가지게 되고 리테인 카운트가 증가된다.\nweak는 약한 참조로 소유권을 가지지 않고 주소값만 가지게 된다."
    }, {
        "question": "ARC 대신 Manual Reference Count 방식으로 구현할 때 꼭 사용해야 하는 메서드들을 쓰고 역할을 설명하시오.",
        "answer": "리테인은 참조 횟수를 증가시키고 릴리즈는 감소시킨다. autorelease는 autoreleasepool 블럭의 끝에서 참조 횟수를 감소시킨다."
    }, {
        "question": "retain 과 assign 의 차이점을 설명하시오.",
        "answer": "리테인은 리테인 카운터를 올리거나 내려주고 소유권을 획득한다\nassign은 값만 변경하고 리테인 카운터를 증가시키지 않는다. 원시 타입에 적합하다."
    }, {
        "question": "순환 참조에 대하여 설명하시오.",
        "answer": "두개의 인스턴스가 서로를 참조할때 메모리상에서 계속 유지된다.\n클로저에서 참조할때"
    }, {
        "question": "특정 객체를 autorelease 하기 위해 필요한 사항과 과정을 설명하시오.",
        "answer": "autoreleasepool 블럭을 사용하고 참조 카운트를 감소시킬때 릴리즈 대신 오토릴리즈를 사용한다.\n함수 내에서 생성한 객체들을 적절한 시점에 한 번에 해제할수 있게 해준다."
    }, {
        "question": "Autorelease Pool을 사용해야 하는 상황을 두 가지 이상 예로 들어 설명하시오.",
        "answer": "많은 임시 객체를 생성하는 루프에서 오토릴리즈풀을 사용하여 다음 반복전에 해당 객체를 삭제할 수 있고\n어플리케이션의 최대 메모리 공간을 줄이는데 도움이 된다."
    }, {
        "question": "다음 코드를 실행하면 어떤 일이 발생할까 추측해서 설명하시오. Ball *ball = [[[[Ball alloc] init] autorelease] autorelease];",
        "answer": "먼저 Ball이 생성되고 초기화된 다음 생성한 Ball이 비워지면 해제된다.\n그리고 다시 오토릴리즈를 하는데 충돌이 날것이다."
    }, {
        "question": "ARC에서 retain count는 무엇인가? compile time 기능인가 runtime 기능인가?",
        "answer": "컴파일타임에 리테인, 릴리즈 호출을 삽입하고 실제 호출은 런타임입니다."
    }, {
        "question": "let, var 비교, 설명",
        "answer": "var는 재할당 가능하고 let은 재할당이 불가능하다"
    }, {
        "question": "Array와 Linked List에 대해 설명, 비교",
        "answer": "어레이는 메모리가 붙어서 할당되고 링크드 리스트는 노드로 이루어져 있다.\n어레이는 랜덤 엑세스가 가능하여 바로 접근을 할수 있고 링크드 리스트는 순차적으로 접근해야 하고\n삽입, 삭제 같은 경우 어레이는 삽입, 삭제를 할때 메모리가 붙게 만들어야 하고 링크드 리스트는 삽입 삭제가 바로 가능하다."
    }, {
        "question": "class와 struct의 차이",
        "answer": "스트럭트는 init메서드가 내장되어 있고 스택영역에 메모리를 저장해서 빠르다.\nstruct를 복수하면 새로운 struct가 생기는데 class는 힙영역에 저장되고 복사를 하면 레퍼런스 카피가 된다.\n그리고 struct는 상속이 안되고 프로토콜만 채택한다."
    }, {
        "question": "class A와 class B에 동일한 함수가 있다면 어떻게 바꿀 수 있나?",
        "answer": "클래스를 상속하거나 동일한 함수를 따로 만들어서 A, B에서 사용할수 있다."
    }, {
        "question": "enum / function / closure 각각 value type 인가 reference type 인가?",
        "answer": "enum은 valueType 이고 function과 클로저는 레퍼런스 타입이다."
    }, {
        "question": "Array, Dictionary, Set 등등의 컬렉션 타입은 value type 인가 reference type 인가?",
        "answer": "value타입이다."
    }, {
        "question": "inter-object communication에 사용하는 디자인 패턴을 아는대로 말해보아라. (최소 3개)",
        "answer": "객체간의 상호 통신 방법인데 딜리게이트 패턴, 노티피케이션, KVO, closure등이 있다."
    }, {
        "question": "heap과 stack의 차이는 무엇인가?",
        "answer": "힙은 객체를 저장하기 위해 사용되고 스택은 변수 및 함수를 호출시 사용되는 변수를 저장한다.\n스택은 생성된 함수가 실행되는 동안에만 존재하고 종료될때 스택 메모리에 적재된 값이 사라진다.\n스택은 스트럭트, 이넘같은 value형 타입을 저장하며 힙보다 빠르다.\n힙은 런타임때 실행되고 스택은 컴파일때 실행된다."
    }, {
        "question": "value type이 heap에 저장되는 경우는 언제인가?",
        "answer": "레퍼런스 타입의 한 부분일때 힙에 저장된다."
    }, {
        "question": "class B: A 일 때 A와 B 둘다 func one()이라는 함수가 있으면 B 인스턴스나 A 인스턴스에서 이 함수를 호출했을 때 둘 중 어떤 함수를 호출할지 어떻게 판단하는가?",
        "answer": "override라는 메서드를 적어주지 않으면 에러가 날것이고 \n만약 A의 one이 private이고 B 인스턴스에서 호출을 했을때 B의 one이 호출이 될것이다."
    }, {
        "question": "함수형 프로그래밍이 무엇인지 설명하시오.",
        "answer": "함수형 프로그래밍은 상태값의 변경 없이 입력된 인자만 의존하기 때문에 항상 예측할수 있는 결과가 나온다.\n함수를 이용해 사이드 이펙트 없이, 선언적으로 프로그래밍 하는것."
    }, {
        "question": "고차 함수가 무엇인지 설명하시오.",
        "answer": "다른 함수를 전달인자로 받거나 함수 실행 결과를 함수로 반환하는 함수.\n예를 들어 map, filter, reduce등이 있다."
    }, {
        "question": "Swift Standard Library의 map, filter, reduce, compactMap, flatMap에 대하여 설명하시오.",
        "answer": "map은 기존 데이터를 변형하여 새로운 컨테이너를 생성하고 filter는 내부의 값을 걸러 새로운 컨테이너로 추출\nreduce는 내부의 컨텐츠를 통합하고, compactMap은 여러개의 배열을 하나의 배열로 만들어 새로운 배열로 반환하고\ncompactMap은 각각의 원소들에 대해서 변형하고자 하는 자료형이 주어졌을때 nil이 아닌 값을 결과로 반환"
    }, {
        "question": "Mutable 객체과 Immutable 객체는 어떤것이 있는지 예를 들고, 차이점을 설명하시오.",
        "answer": "Immutable는 Struct를 let으로 선언했을때 불변이 된다. Mutable는 var로 선언할때 가변이 된다."
    }, {
        "question": "@property로 선언한 NSString* title 의 getter/setter 메서드를 구현해보시오.",
        "answer": "@synthesize title=_title;"
    }, {
        "question": "-performSelector:withObject:afterDelay: 메시지를 보내면 인자값의 객체는 retain되는가? 그 이유를 함께 설명하시오.",
        "answer": "retain됩니다. delay가 없으면 retain되지 않지만 delay를 주고 나중에 실행되기 때문에 retain됩니다."
    }, {
        "question": "method swizzling이 무엇이고, 어떨 때 사용하는지 설명하시오.",
        "answer": "원래의 메서드를 런타임때 원하는 메서드로 바꾸어 사용할수 있는 방법입니다."
    }, {
        "question": "atomic, nonatomic",
        "answer": "아토믹은 중단되지 않는다는 의미로 다른 프로세스나 쓰레드에 의해 인터루프되지 않고 수행이 완료될때까지 무결성을 유지한다.\n논아토믹은 데이터의 무결성을 보장받지 않는다.\n아토믹으로 설정된 프로퍼티의 게터 세터 메서드는 lock을 사용해 멀티쓰레드에 안전하게 처리가 되는데 이 과정에서 다른 쓰레드가 접근을 할수 없기 때문에 불필요한 성능 저하가 발생할수 있어 논아토믹으로 사용된다."
    }, {
        "question": "OOP에 대한 POP의 장점",
        "answer": "OOP는 subclass가 단 하나의 서브클래스만 상속이 가능하다는 단점이 있어서 복잡도가 높아지고 관리가 어려워진다.\nPOP는 필요한 부분만 프로토콜로 분리해서 만들수 있고 다중 프로토콜 상속이 가능하기 때문에 확장성에서 좋다."
    }, {
        "question": "bridging header와 umbrella header",
        "answer": "Swift프로젝트에서 Objective-C 코드를 사용하기 위해서 필요한 파일이 브릿지 헤더이고\nObjective-C에서 Swift 코드를 import하기 위해 사용되는 파일이 엄브렐라 헤더이다."
    }, {
        "question": "App Crash, Memory leak 해결 방법",
        "answer": "XCode에서 제공하는 instruments툴을 보고 leak에 대한 원인이나 분석을 할 수 있다."
    }, {
        "question": "weak, assign, strong의 차이점?",
        "answer": "weak 는 약한참조이고 객체를 소유하지 않고 주소값만 가지고 있는다.\nstrong는 강한참조이고 객체를 소유하고 레퍼런스 카운터를 증가시킨다.\nassign은 할당한다는 의미이다."
    }, {
        "question": "nil, Nil, NULL, NSNull에 대한 설명",
        "answer": "nil: object가 없을때 (NSString *a = nil;)\nNil: class가 없을때 (Class *a = Nil;)\nNULL: 포인터 주소값이 없을때(int *a = NULL;)\nNSNull: collection item을 null로 설정할 필요가 있을때([a.addObject:[NSNull null]];)"
    }, {
        "question": "block 키워드에 대한 설명과 왜사용하는 것인지?",
        "answer": "블럭객체 안에서는 외부 변수를 사용할때 value카피가 되기 때문에 외부 변수를 레퍼런스 카피를 하기 위해서는 block를 외부 변수에 써야 한다."
    }, {
        "question": "@synthesize란?",
        "answer": "컴파일 시에 미리 선언해둔 프로퍼티에 맞게 세터와 게터를 생성해준다."
    }, {
        "question": "서브클래싱과 서브타이핑 (Subclassing & Subtyping)",
        "answer": "서브클래싱은 구현되어 있는 클래스를 상속하는것이고\n서브타이핑은 정의되어 있는 인터페이스를 구현하는것이다."
    }, {
        "question": "메서드와 함수의 차이",
        "answer": "메서드는 클래스 구조체 열거형에 속하지만 함수는 속하는곳이 없다."
    }, {
        "question": "스위프트의 빌드",
        "answer": "Swift Code -> Swift AST -> Raw Swift IL -> Canonical Swift IL -> LLVM IR -> Assembly -> Executable\nLLVM:Frontend->LLVM Optimizer->LLVM Backend"
    }, {
        "question": "ABI stability",
        "answer": "Application Binary Interface\n응용 프로그램과 라이브러리 사이에 필요한 저 수준 인터페이스\nABI stability는 컴파일러 버전이 안정적인 ABI를 준수하는 바이너리를 생성하루 수 있도록 ABI를 잠그는것.\n1. Source compatibility(소스 호환성)\n최신 컴파일러가 이전 버전의 Swift로 작성된 코드를 컴파일 할수 있음\n2. Binary framework & runtime compatibility\n여러 Swift버전에서 작동하는 binary form(이진형식)의 프레임워크를 배포할수 있음.\nBinary framework = 스위프트 모듈파일 + 공유 라이브러리\n\n(API: Application Programming Interface: 응용 프로그램에서 사용할수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할수 있게 만든 인터페이스)"
    }, {
        "question": "block,non-block ,sync,async",
        "answer": "Blocking/NonBlocking은 호출되는 함수가 바로 리턴하느냐 마느냐이다.\n호출되는 함수가 바로 리턴하는거는 넌블럭이고 자신의 작업을 모두 마칠때까지 제어권을 넘겨주지 않으면 블럭이다.\nSynchronous/Asynchronous는 호출되는 함수의 작업완료 여부를 누가 신경쓰느냐이다."
    }, {
        "question": "TDD",
        "answer": "테스트 더블: 실제 객체를 대신하여 테스팅에서 사용되는 모든 방법\n더미: 객체는 전달되지만 사용되지 않는 객체. 가짜 값\nFake: 동작하는 구현을 가지고 있지만 실제 프러덕트에는 적합하지 않은 객체. 예를 들어 인메모리 데이터베이스\nStub: 테스트에서 호출된 요청에 대해 미리 준비해둔 결과만 제공\nSpy: Stub의 역활을 하면서 약간의 정보를 기록 예를들어 메일링서비스에서 발송된 메일 갯수 기록\nMock: 호출에 대한 기대를 명세하고, 해당 내용에 따라 동작하도록 프로그래밍된 객체. 메서드 호출의 특정 순서가 있다고 가정"
    }, {
        "question": "Responder Chain 구조에 대해 설명하고, First Responder 역할에 대해 설명하시오.",
        "answer": "이벤트나 액션 메시지를 처리할 책임을 다른 다음 객체에게 전송할수 있습니다. 처리 될 때 까지 상위 객체들로 이동하고 마지막까지 처리되지 않으면 버려집니다.\n이벤트들을 처음으로 받는 responder객체를 first responder라고 합니다.\n앱이 이벤트를 핸들링하기 가장 적합하다고 간주합니다."
    }, {
        "question": "NSObject부터 UIButton 까지 상속 과정의 계층과 역할을 설명하시오.",
        "answer": "UIResponder는 이벤트가 발생하면 UIKit은 이 이벤트를 처리할수 있도록 리스폰더 객체에 전달합니다.\nUIView\nUIControl는 특정 액션등을 전달하는 시각적인 요소들의 기반이 되는 클래스입니다.\nUIResponder보다 상위 수준의 메서드를 제공"
    }, {
        "question": "shallow copy와 deep copy의 차이점을 설명하시오.",
        "answer": "깊은 복사는 데이터 자체를 통째로 복사하고 복사된 객체는 완전히 독립적인 메모리를 차지하게 됩니다.\nvalue type의 객체들은 깊은 복사를 하게됩니다.\n얕은 복사는 값을 복사하는게 아니라 주소값을 복사하여 같은 메모리를 가리키게 된다.\n레퍼런스 타입을 복사하는 경우 얕은 복사가 일어난다.\n레퍼런스 타입에서 깊은 복사를 하려면 copy 메서드를 사용한다.\n내부에 레퍼런스 타입이 있는 경우에는 내부 레퍼런스 타입도 깊은 복사를 해주어야 한다."
    }, {
        "question": "Push Notification 방식에 대해 설명하시오.",
        "answer": "앱이 apns에게 device token을 요청합니다. 디바이스 토큰은 애플에서 정한 고유 식별자를 포함시킨 푸시가 전송되는 app의 주소입니다.\napns가 앱에게 디바이스 토큰을 알려주고 앱이 푸시 서버에게 디바이스 토큰을 보냅니다.\n푸시 서버는 apns에게 디바이스토큰과 원하는 데이터를 보냅니다. 이 과정에서 TLS통신을 하기 때문에 푸시 서버에 인증서가 있어야 합니다.\napns는 해당 디바이스 토큰으로 데이터를 보내게 되고 디바이스는 알림이 뜨게 됩니다."
    }, {
        "question": "Plist 파일 구조와 Plist 파일에 저장된 데이터를 다루기 적합한 클래스를 설명하시오.",
        "answer": "Bundle 클래스. 앱 번들을 접근할수 있고 plist, 어셋, string파일 등을 가져올수 있다."
    }, {
        "question": "Core Data와 Sqlite 같은 데이터 베이스의 차이점을 설명하시오.",
        "answer": "Core Data는 영구 저장소로 사용할수 있지만 데이터베이스가 아니고 객체 그래프를 관리합니다.\n객체 그래프는 상호 연결된 개체의 모음들입니다.\nSQLite보다 더 많은 메모리를 사용하고 더 많은 저장공간을 사용하고 더 빠릅니다.\n"
    }, {
        "question": "JSON 데이터를 처리하는 방식과 파서, 객체 변환 방식에 대해 설명하시오.",
        "answer": "JSONSerialization을 사용하여 json형태의 문자열을 AnyObject로 만들거나 객체를 json형태의 문자열로 만듭니다.\n또는 Codable 프로토콜을 사용하여 JSON형태를 객체에 담을 수 있습니다."
    }, {
        "question": "웹 서버와 HTTP 연결을 사용해서 데이터를 주거나 받으려면 사용해야 하는 클래스와 동작을 설명하시오.",
        "answer": "URLSession을 사용하여야 하고 dataTask 메서드를 사용합니다.\n콜백으로 데이터를 받을 수 있고 또는 딜리게이트로 상태를 받을 수 있습니다.\n다운로드 태스크, 업로드 태스크등이 있고 딜리게이트가 살짝씩 다릅니다."
    }, {
        "question": "Protocol에서는 왜 var만 되는지 설명하시요.",
        "answer": "프로토콜에는 상수가 올 수 없습니다."
    }, {
        "question": "의존성 주입에 대하여 설명하시오.",
        "answer": "객체 내부에서 객체를 생성하는게 아니라 외부에서 이니셜라이져나 변수, 메서드에 주입을 해줍니다."
    }, {
        "question": "Reactive Programming이 무엇인지 설명하시오.",
        "answer": "반응형 프로그래밍이고 어떤 변화에 반응한다는것이다.\n특정 데이터를 관찰하고 있다가 데이터가 변하면 반응을 하고 변한 이벤트를 가지고 관련된 업데이트 로직이 수행된다."
    }, {
        "question": "RxSwift에서 Hot Observable과 Cold Observable의 차이를 설명하시오.",
        "answer": "Hot Observable는 구독 여부에 상관 없이 이벤트를 발생시키기 때문에\n일정시간이 지난 다음 구독을 하게 되면 이전 이벤트를 받아볼수 없고\nCold Observable은 구독과 동시에 동작하며 그 이전에는 이벤트가 발생되지 않습니다.\nHot Observable 대표적인 것들은 타이머, 이벤트 등이 있고 Cold Observable의 대표적인 것들은 HTTP 통신 등이 있습니다."
    }, {
        "question": "Copy on write",
        "answer": "배열의 요소가 백만개 정도되는 array를 복사하면 단순이 메모리의 주소만 복사한다. 얕은복사가 이루어진다.\n이후 변화가 발생하면 뒤늦게 깊은복사가 일어난다."
    }, {
        "question": "프로세스와 스레드 비교, 설명",
        "answer": "프로세스는 실행중이 프로그램이고 자원이 할당된다.\n운영체제로부터 시스템 자원을 할당받는 작업의 단위이다.\n프로세스는 각각의 독립된 메모리 영역(Code, Data, Stack, Heap)을 각자 할당\n프로세스 간 자원 공유는 어렵다.\n쓰레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름이다.\n쓰레드는 프로세서가 아니라 프로세서 내에서 동작하는것이기 때문에 메모리 영역을 독립적으로 할당받지 못한다.\nCode, Data, Heap영역은 공유하고 Stack영역만 독립적으로 할당받을수 있다.(스택은 LIFO이라서)\nCode,Data,Heap영역을 공유하기때문에 Context Switching이 빠르다.\n자원을 할당하는게 아니라 생성/종료 시간도 프로세스 보다 빠르다.\n하지만 동기화문제가 있고 독립적이지 않아 하나의 쓰레드에서 문제시 전체 쓰레드가 영향을 받을수 있다."
    }, {
        "question": "Subject와 drive의 차이를 설명하시오.",
        "answer": "Drive는 onError가 없고 UI용이라 MainScheduler에서 동작한다."
    }, {
        "question": "MVVM, MVC, Ribs, VIP 등 자신이 알고있는 아키텍쳐를 설명하시오.",
        "answer": "MVVM은 Model View ViewModel이고\nModel은 데이터, 비지니스 로직 등입니다.\nView는 사용자 이벤트를 수신하고 데이터를 표현하는 유저 인터페이스 부분이고 ViewController도 포함되어 있습니다.\nViewModel은 로직을 담당하고 있습니다.\n\n유저가 뷰에 어떤 액션을 했을때 뷰모델에게 보내준다.\n뷰모델은 모델을 업데이트 하고\n뷰모델에 결과를 알리고 뷰를 갱신합니다.\n\n뷰모델과 뷰는 바인딩이 되어 있고 \n뷰모델은 모델을 업데이트 하고\n모델은 뷰모델에게 노티피로 알려준다.\n\n데이터 바인딩은 Model과 UI요소간의 싱크를 맞춰준다."
    }, {
        "question": "Rx 설명",
        "answer": "Observer & Observable\n\nObservable 클래스는 T형태의 데이터를 전달할수 있는 이벤트들을 비동기적으로 생성하는 기능\nObservable는 해당 Event를 Observer 관찰자에게 전달하고 Observer는 이벤트를 전달받으면 처리한다.\nObservableType 프로토콜은 subscribe 메서드가 있다.\n\nObserver는 Observable을 관찰한다. Observer는 Observable이 방출하는 아이템들에 대해 반응한다.\nObserverType 프로토콜은 on 메서드가 있다.\n\n\nDispose\n\ndispose() 메서드는 구독을 취소하여 Observable을 수동으로 종료시긴다.\ndisposeBag은 disposable을 모았다가 한번에 처분한다. subscription 마다 별도로 dispose 를 관리하는건 리스크도 있고 별로 좋지 않다.\n\n\nTrait\n\nTrait는 Observable보다 좁은 의미의 Observable이고\nSingle, Completable, May가 있다.\nSingle은 항상 단일 요소 또는 오류를 방출한다.\nCompletable은 완료나 에러를 방출한다.\nMaybe는 Single과 Completable 사이의 변형이고 단일요소를 방출하거나 방출하지않고 완료하고나 에러를 낸다.\n\n\nRxCocoa의 Trait\n\nControlProperty 컨트롤에 데이터를 바인딩 하기 위해 사용한다.\nControlEvent 컨트롤의 이벤트를 받기 위해 사용한다.\nDriver 에러를 방출하지 않고 메인 스레드에서 사용된다. (state 모델링)\nSignal driver와 비슷한데 자원을 공유하지 않는다. (event 모델링)\n\n\nSubject\n\nSubject는 Observable와 Observer이다.\n이벤트를 외부에 전달해줄 경우에 사용해 delegate 대신 사용하기도 한다.\nPublishSubject는 .competed, .error 이벤트가 발생할때까지 subscribe한 이후 이벤트를 방출한다.\nBehaviorSubject는 초기값을 가지고 항상 직전의 값부터 구독한다.\nReplaySubject는 생성시 선택한 특정 크기만큼 일시적으로 캐시나 버퍼에 저장해서 최신 요소들을 모두 방출한다.\nAsyncSubject는 제일 마지막 값과 completed또는 값없이 에러만 받습니다.\nSubject는 completed, error 이벤트가 발생하면 subscribe가 종료된다.\n\n\nRelay\n\nRelay는 RxCocoa의 클래스이고 Subject는 RxSwift의 클래스이다.\nRelay는 completed, error 이벤트를 발생시키지 않고 dispose되기 전까지 계속 작동하기 때문에 UI Event에서 사용된다.\nRelay내에 옵저버블을 bind시키는 메서드가 있지만 옵저버블이 절대 종료되지 않는다는 보장이 없는 이상 사용하는건 바람직하지 않습니다.\nPublishRelay는 PublishSubject의 래퍼클래스이다. 그래서 subscribe한 이후 이벤트를 방출한다.\nBehaviorRelay는 BehaviorSubject의 Wrapper클래스이다. 초기값을 가지고 항상 직전의 값부터 구독한다. (variable 대신 사용이 된다)\n\n\nDriver\n\n옵저버블이 에러를 무시하고 싶으면 asDriver()을 해서 Driver로 변경하면 된다.\nDriver를 하면 drive로 구독하는데 drive는 onError가 없다. UI용이다. MainScheduler에서 동작한다. (Relay와 Driver는 UI용)\n\n\nDriver & Signal\n\nDriver와 Signal은 UI에 사용하기위해 RxCocoa에 도입된 Observable이다.\n절대 종료되지 않고 MainScheduler에서 돌아간다.\nDriver는 drive() 메서드로 구독하고 최근 이벤트를 받는다.\nSignal은 emit() 메서드로 구독하고 최근 이벤트를 받지 않는다.\n원래 새로운 옵저버가 옵저버블을 구독할때마다 새로운 스트림이 생기는데 사이드 이펙트가 없고 빨리 사라질 스트림이라면 상관없지만 그게 아니고 메모리에 상주하거나 종료되지 않는 것이라면 메모리 문제가 생길수도 있는데\n이 문제를 해결하기 위해 Driver이나 Signal을 쓴다.\nDriver이나 Signal은 공유 옵저버블이다.\n\n\nShare\n\n옵져버블을 공유하는것은\nshare와 publish, replay가 있는데\npublish와 replay는 connect()를 해줘야 방출한다.\n그 이유는 Observable을 ConnectableObservable로 변환해주기 때문이다.\nrefCount() 메서드가 있는데 이 메서드는 ConnectableObsrevable에 Connect와 Disconnect를 자동으로 담당하여 ConnectableObsrevable를 Obsevable처럼 사용할수 있게 해준다.\nshare는 publish().refCount 와 같다.\nreplay는 구독시 지정한 버퍼 크기만큼 이벤트를 저장하고 전달한다.\n\n\nObserveOn & SubscribeOn\n\nObserveOn은 Event Flow의 스케쥴러를 변경해준다. (아래쪽으로 영향)\nSubscribeOn은 Subscribe Flow의 스케쥴러를 변경해준다. (위쪽으로 영향)\nObservable.of(...) // scheduler 2\n    .filter { ... } // scheduler 2\n    .observeOn(scheduler1) // scheduler 2\n    .map { ... } // scheduler 1\n    .subscribeOn(scheduler2) // scheduler 1\n     ... //각종 연산들, scheduler 1\n    .subscribe { // scheduler 1\n        ...\n    }.disposed(by:bag)\nSubscribe가 될때 옵져버블은 Subscribe를 수행했던 스케쥴러를 따라간다.\nSubscribeOn 디폴트 스케쥴러를 결정하고 여러번 쓸 경우 가장 처음에 쓴거만 적용된다. 한번만 사용된다.\nObserveOn이 되면 ObserveOn로 지정된 스케쥴러로 변경된다. 여러번 사용해도 된다.\n\n\nScheduler\n\nScheduler는 특정 작업이 수행되는 시점과 방법(같은 스레드에서 동기적인지 다른 스레드에서 비동기적인지)을 결정한다.\n내부적으로 GCD를 사용하고 있다.\nCurrentThreadScheduler(serial): 현재 스레드에서 작업을 수행한다. 기본 스레드\nSerialDispatchScheduler(serial): 만들때 인자로 넘긴 DispatchQueue에서 작업이 수행된다.\nConcurrentDispatchQueueScheduler(Concurrent): 만들때 인자로 넘긴 DispatchQueue. 백그라운드 작업.\nMainScheduler & ConcurrentMainScheduler: 메인 스레드에서 작업이 수행하게 한다.\nOperationQueueScheduler(Concurrent): OperationQueue를 사용한 Scheduler\nVirtualTimeScheduler: 내부적으로 clock을 가지고 있어서 clock기준으로 작업 수행 (Testing)\n\n\nHot Observable & Cold Observable\n\nHot Observable은 구독과 상관없이 이벤트가 발생하고 이벤트를 처음부터 관찰할수 없다.\nHot Observable은 여러 옵저버가 하나의 옵저버블을 공유할수 있다. \nCold Observable은 구독시 이벤트가 발생하고 이벤트를 처음부터 관찰할수 있다.\nCold Observable은 옵저버 마다 별도의 옵저버블 인스턴스를 가지게 된다.\n\nHot Observable의 대표적인 것은 UIEvent, 타이머 등이고\nCold Observable의 대표적인 것은 Http요청이다.\n\n\nRxCocoa\n\nRxCocoa의 ControlProperty 은 값을 주입할수도 있고 관찰할수도 있다.\n얘를들어 UITextField의 text는 ControlProperty이다.\nBinder는 값을 주입시킬수는 있지만 관찰할수는 없다.\n\n\nProxy\n\ndelegate 를 rx에서 proxy로 바꾸려면\ndelegate가 optional이면 methodInvoked를 사용해서 파라미터를 담은 옵저버블을 전달한다.\n아니면 subject를 만들어서 옵저버블을 전달한다.\n\n\nObservable의 연산자들은 \nfrom, of: of는 Variadic만 가능하고(어레이등 X) from은 아무렇게나 된다.\ngenerate: for 문 등을 대체하여 사용할수 있다.\ndeferred: 옵저버블이 만들어지는 시점이 미루어진다. (상태에 따라 다른값을 보낼 수 있다.)\nfilter\ndebounce: 이벤트가 일어난 다음 일정 시간 이후에 이벤트가 방출된다.\nthrottle: 이벤트가 발생하는 최소간격 제한을 할수있다. 이벤트가 방출된 다음 일정시간동안 이벤트 방출을 막고 일정시간이후 마지막 이벤트가 방출된다.\ntake: 이벤트 갯수를 제한한다.\nskip: 이벤트 발생을 특정수만큼 스킵한다.\nmap: 이벤트 타입을 사용하기 편한 타입으로 가공한다.\nflatmap: 옵져버블을 받아서 새로운 옵저버블을 방출한다.\nflatMapFirst: 이전에 생성한 옵져버블의 동작이 다 끝날때까지 새로 생성한 옵져버블은 무시\nflatMapLatest: 새로 아이템이 전달되면 이전 옵져버블은 dispose하고 새로운 옵져버블을 만든다.\ngroupBy: 이벤트를 분류\nbuffer: 이벤트를 특정 횟수, 시간의 단위로 묶어서 한꺼번에 처리. Array형태로 방출\nwindow: 이벤트를 특정 횟수, 시간의 단위로 묶어서 한꺼번에 처리. Observable 형태로 방출\nmerge: Observable을 합쳐줌\ncombineLatest: \nstartWith\nzip\nconcat\nshare: 옵저버블을 공유한다.\ndistinctUntilChanged: 이전 이벤트와 비교해서 값이 다를 경우에만 이벤트를 방출한다. (예를들어 textField가 resign되면 이벤트가 text의 발생하는데 막아준다.)"
    }
]